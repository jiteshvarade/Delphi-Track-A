# ADR-002: State Management for Logging (Local Storage)

**Status**: Accepted  
**Date**: 2025-10-31  
**Authors**: Development Team  
**Decision Makers**: Technical Lead

---

## Context

Delphi Reader needs to track user interactions and AI agent actions for:

1. **Product Analytics**: Understanding feature usage patterns
2. **Debugging**: Troubleshooting issues reported by users
3. **User Awareness**: Showing users their activity history
4. **Persistence**: Logs should survive page refreshes

**Requirements**:
- Log all user actions (navigation, AI calls, selections)
- Store logs across sessions
- Display logs on a dedicated page
- Minimal performance overhead
- No external dependencies or backend required

---

## Decision

We will use:
- **React Context API** for global log state management
- **localStorage** for persistence across sessions
- **Custom hook pattern** (`useLog`) for accessing logging functionality
- **Simple array structure** for log entries with timestamps

---

## Rationale

### Why React Context API?

**Pros**:
- ‚úÖ **Built into React**: No additional dependencies
- ‚úÖ **Global state access**: Any component can read/write logs
- ‚úÖ **Simple API**: Provider + custom hook pattern
- ‚úÖ **Good performance**: Minimal re-renders with proper memoization
- ‚úÖ **Type-safe**: Works seamlessly with TypeScript

**Alternatives Considered**:
- **Redux/Redux Toolkit**: Overkill for simple log array, adds complexity
- **Zustand**: External dependency, not needed for this scale
- **MobX**: Heavier library, steeper learning curve
- **Prop drilling**: Would pollute component tree with log callbacks

**Conclusion**: Context API is the right tool for sharing logs across components without over-engineering.

---

### Why localStorage?

**Pros**:
- ‚úÖ **Browser native**: No library needed
- ‚úÖ **Persistent**: Survives page refresh and browser restart
- ‚úÖ **Synchronous API**: Easy to use, no async complexity
- ‚úÖ **5-10MB storage**: More than enough for log entries
- ‚úÖ **Universal support**: Works in all modern browsers

**Alternatives Considered**:
- **IndexedDB**: Over-engineered for simple log array, async API complexity
- **SessionStorage**: Loses data when tab closes (not persistent enough)
- **Cookies**: 4KB limit, sent with every request (wasteful)
- **Backend API**: Requires server infrastructure, adds latency

**Conclusion**: localStorage balances persistence, simplicity, and performance for client-side logging.

---

### Why Simple Array Structure?

**Log Entry Schema**:
```typescript
interface LogEntry {
  timestamp: string  // ISO 8601 format
  message: string    // Human-readable description
}
```

**Pros**:
- ‚úÖ **Easy to serialize**: `JSON.stringify` / `JSON.parse` work out of the box
- ‚úÖ **Simple queries**: Array methods (filter, map, slice) for display
- ‚úÖ **Append-only**: Fast writes, no complex indexing needed
- ‚úÖ **Human-readable**: Easy to debug in DevTools

**Alternatives Considered**:
- **Object with IDs as keys**: Harder to maintain order, more complex serialization
- **Linked list**: Unnecessary complexity for display-only use case
- **Nested objects**: Over-normalization for simple logs

**Conclusion**: Array of objects is the simplest data structure that meets all requirements.

---

## Implementation Details

### LogContext Provider

```tsx
// src/context/LogContext.tsx
export const LogProvider = ({ children }) => {
  const [logs, setLogs] = useState<LogEntry[]>(() => {
    const stored = localStorage.getItem('delphi-logs')
    return stored ? JSON.parse(stored) : []
  })

  const addLog = (message: string) => {
    const entry = { timestamp: new Date().toISOString(), message }
    setLogs(prev => {
      const updated = [...prev, entry]
      localStorage.setItem('delphi-logs', JSON.stringify(updated))
      return updated
    })
  }

  return (
    <LogContext.Provider value={{ logs, addLog }}>
      {children}
    </LogContext.Provider>
  )
}
```

### Custom Hook Pattern

```tsx
export const useLog = () => {
  const context = useContext(LogContext)
  if (!context) {
    throw new Error('useLog must be used within LogProvider')
  }
  return context
}
```

### Usage in Components

```tsx
const { addLog } = useLog()

const handleAction = async (action: string) => {
  addLog(`User triggered ${action}`)
  try {
    const result = await callAgent({ action })
    addLog(`${action} succeeded`)
  } catch (error) {
    addLog(`${action} failed`)
  }
}
```

---

## Consequences

### Positive

‚úÖ **Zero dependencies**: Uses only React and browser APIs  
‚úÖ **Fast writes**: Synchronous localStorage writes don't block UI  
‚úÖ **Persistent logs**: Users can close/reopen tabs without losing history  
‚úÖ **Easy debugging**: Logs visible in DevTools ‚Üí Application ‚Üí Local Storage  
‚úÖ **Type-safe**: TypeScript ensures correct log structure  
‚úÖ **Simple testing**: Easy to mock Context in unit tests

### Negative

‚ö†Ô∏è **Storage limits**: localStorage has ~5-10MB limit (risk of overflow)  
‚ö†Ô∏è **Synchronous I/O**: Large log arrays could block main thread during parse/stringify  
‚ö†Ô∏è **No compression**: JSON serialization is verbose  
‚ö†Ô∏è **Single-tab state**: Changes in one tab don't sync to other tabs  
‚ö†Ô∏è **No analytics backend**: Logs stay on user's device, not aggregated

### Mitigations

- üßπ **Log rotation**: Implement max 1000 entries, auto-trim oldest logs
- ‚ö° **Lazy loading**: Only parse localStorage when LogsPage mounts
- üîÑ **Storage event listener**: Sync logs across tabs if needed
- üìä **Future enhancement**: Add optional backend export for analytics

---

## Scalability Considerations

### When to Migrate Away

Consider moving to a more robust solution if:

1. **Log volume exceeds 5MB**: Switch to IndexedDB or backend API
2. **Real-time sync needed**: Use WebSocket or Server-Sent Events
3. **Analytics required**: Integrate with Mixpanel, Amplitude, or custom backend
4. **Complex queries needed**: Use IndexedDB with indexes

### Migration Path

1. Keep Context API for state management
2. Replace localStorage with IndexedDB or API calls
3. Add log export feature (JSON download for users)
4. Implement server-side aggregation and analytics dashboard

---

## Alternatives Not Chosen

| Solution                  | Reason for Rejection                                      |
|---------------------------|----------------------------------------------------------|
| Redux + redux-persist     | Too complex for simple log array, adds boilerplate       |
| MobX + mobx-persist       | External dependencies, steeper learning curve            |
| IndexedDB                 | Async API complexity not justified for current scale     |
| Backend API (Firebase)    | Requires external service, adds latency, cost concerns   |
| In-memory only (useState) | Loses logs on page refresh (bad UX)                      |
| URL query params          | 2KB limit, leaks logs in browser history                 |

---

## Performance Metrics

| Operation            | Latency     | Notes                                      |
|----------------------|-------------|--------------------------------------------|
| addLog (write)       | < 1ms       | Synchronous localStorage.setItem           |
| Read logs on mount   | < 5ms       | JSON.parse + setState                      |
| Display 100 logs     | < 10ms      | Array.map rendering                        |
| Clear all logs       | < 1ms       | localStorage.removeItem                    |

**Tested with**: 500 log entries, Chrome DevTools Performance profiling

---

## Security Considerations

- üîí **No sensitive data**: Never log passwords, tokens, or PII
- üßπ **User-controlled**: Add "Clear Logs" button on LogsPage
- üëÅÔ∏è **Transparent**: Logs visible to user, no hidden tracking
- üö´ **No third-party access**: Data stays on user's device

---

## Testing Strategy

### Unit Tests (Vitest)
```tsx
test('LogProvider adds log entry', () => {
  const { result } = renderHook(() => useLog(), {
    wrapper: LogProvider
  })
  act(() => result.current.addLog('Test message'))
  expect(result.current.logs).toHaveLength(1)
  expect(result.current.logs[0].message).toBe('Test message')
})
```

### E2E Tests (Playwright)
```tsx
test('logs persist across page refresh', async ({ page }) => {
  await page.goto('/article/1')
  await page.locator('button:has-text("Explain")').click()
  await page.reload()
  await page.goto('/logs')
  await expect(page.locator('text=User triggered Explain')).toBeVisible()
})
```

---

## Related ADRs

- [ADR-001: Choosing Vite + React + Tailwind CSS](./ADR-001.md)

---

## References

- [React Context API](https://react.dev/reference/react/createContext)
- [localStorage MDN](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage)
- [Web Storage API Limits](https://web.dev/articles/storage-for-the-web)
